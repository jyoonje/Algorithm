Spring Security와 jwt토큰을 이용한 클라이언트 인증/인가 기능 구현 중 마주한 트러블슈팅 기록이다.

현재 프로젝트의 기능은 크게 회원가입/로그인, 로그인 한 내 정보 조회이다.
나는 Member 엔티티의 @id 값으로 UUID타입의 id 필드를 만들어놓은 상태이며, OracleDB의 ID컬럼은 다음과 같이 정의되어 있었다. " ID VARCHAR2(30) PRIMARY KEY "

회원가입을 진행하면 DB의 해당 컬럼의 값으로 16진수가 들어갔고(예시: 8DD2100E826042DE99CDAA01EC6C9BEE), 회원 정보 조회 기능에서 회원의 ID값으로 조회를 시도하면, 내가 정의해놓았던 MemberNotFoundException이 발생했다. 즉, 해당하는 ID값을 가진 회원이 없다는 것이다.

결론적으로 말하자면, UUID가 무엇인지에 대한 이해가 없이 접근했으며, JPA와 oracle 간의 UUID 처리 방식에 대한 이해 또한 없었던 것이다. 대략 4시간의 삽질에 대한 해결 과정에 대해 짧은 정리를 하려고 한다.


우선, UUID란 무엇인지 빠르게 알아보고 가겠다.

- UUID란?
UUID(범용 고유 식별자(universally unique identifier))는 128비트의 수이다. 표준 형식에서 UUID는 32개의 16진수로 표현되며 총 36개의 문자(32개의 문자와 4개의 하이픈)로 된 8-4-4-4-12라는 5개의 그룹을 하이픈으로 구분한다. 예시는 다음과 같다. "550e8400-e29b-a716-446655440000"


진행중인 프로그램의 Member 엔티티에서 UUID타입의 필드 "id"는 다음과 같이 정의되어있었다.
@Id
@GeneratedValue(strategy = GenerationType.UUID)
private UUID id;


위에서 언급했듯 나의 OracleDB의 ID컬럼은 VARCHAR2(255) 타입이었고, JPA에서 Oracle로 UUID를 처리하는 방식에 대한 이해도가 전무했다. 

구글링을 해보니, "UUID에는 16바이트가 필요하다. DB컬럼을 BINARY 타입으로 수정해야한다." 는 문구를 읽게되었고, 해당 컬럼의 타입을 BINARY(16)으로 수정하였다.

하지만 내가 사용하는 오라클 버전은 BINARY타입을 지원하지 않는듯했다. 따라서 chat-gpt의 도움을 받아 RAW(16)타입으로 해당 컬럼을 선언했다.

RAW타입은 OracleDB에서 이진 데이터를 저장하기 위해 사용되며, UUID와 같은 고정 길이의 이진 데이터를 다룰 때 종종 사용된다고 한다. 

RAW(16)에서 '16'은 다들 알다시피 길이를 16바이트로 고정한다는 뜻이며, 길이를 16바이트보다 길게 설정해놓으면 남은 자릿수를 전부 0으로 패딩(padding)처리 한다고한다.


결론: 엔티티에서 @GeneratedValue 어노테이션으로 자동 생성한 ID값이 OracleDB의 Varchar2(255)타입으로 매칭하면 이진수로 들어가지도 않고, 남는 길이가 전부 0으로 패딩된다. 
따라서, OracleDB의 컬럼을 RAW(16)으로 수정하고, 엔티티의 id필드에 @Column(columnDefinition = "BINARY(16)") 어노테이션을 추가해주면 DB컬럼의 정의를 직접 이진 데이터 타입이며, 최대 16바이트임을 지정할 수 있다.
