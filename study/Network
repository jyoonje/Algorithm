⌈네트워크 정리⌋

° 목차
- Local Area Network
- Wide Area Network
- Internet Protocol
- Transport Layer Protocol
- Application Layer Protocol


- 컴퓨터간의 통신 방법: 물리적 연결 또는 전자기파를 이용한 전기신호로 이진법을 이용하여 통신한다.


° Local Area Network

1. HUB: Local Area Network에서 여러대의 컴퓨터가 통신하기 위해 예전에 쓰이던 디바이스
HUb의 문제점: 데이터 충돌, 모든 컴퓨터에 정보 전송, ... 
(더 이상 쓰이지 않고 스위치로 대체됨)

2. MAC주소: Local Area Network에서 Hub를 이용해서 통신하던 시절, 컴퓨터A에서 정보를 전송하면 모든 컴퓨터로 정보가 전송되어 혼란을 야기하는 이슈를 해결하기 위해, 특정 컴퓨터로 보낸다는 의미를 담기 위해 각 컴퓨터마다 가지고 있는 고유의 MAC주소를 데이터에 담아서 보냄.

정의: 네트워크 인터페이스 카드에 각인된 물리적 주소.
네트워크 인터페이스 카드는 네트워크에 연결되는 모든 디바이스에 존재한다.

MAC 주소 구조: 6 bytes(48 bit)
MAC 주소 예시: fe-1b-63-84-45-26 (16진법)
* 16진법 fe == 2진법 11111110이기 때문에 6 bytes 인 것이다.
첫 3바이트는 IEEE에서 기업이나 단체에 할당.
fe-1b-63: 이 디바이스를 만든 회사
뒤의 3 바이트: 해당 회사에서 순차적으로 할당


3. 프레임(Frame): 컴퓨터A에서 B로 정보를 보낼 때 사용하는 형식.
간단한 형식: '  목적지 MAC 주소 | 소스 MAC 주소 | 데이터  '
(사실은 더 복잡하다.)


4. 스위치(Switch): HUB의 대체자로, 연결된 컴퓨터의 MAC주소를 기억하고 있다. -> 컴퓨터A 에서 B로 정보를 보내고 싶다면, 프레임에 담긴 MAC주소를 확인 후 컴퓨터B로 전송한다.(C에도 전송되는 문제 해결) 또한, Hub에서 양방향 데이터 전송 시 충돌이 일어나는 문제 또한 해결함.


° Wide Area Network

: 서로 다른 Local Area Network 사이에 통신을 위한 '라우터'가 개입하면 그 때 부터 Wide Area Network이다.

- Local Area Network (이하 LAN) 에 연결되지 않은 컴퓨터간의 통신 시, 목적지 컴퓨터의 MAC주소를 알아도 통신할 수 없기에, 라우터간의 IP주소를 사용하여 목적지 컴퓨터와 연결된 라우터와 연락을 주고받는다.(소스 컴퓨터와 목적지 컴퓨터도 IP주소를 갖는다)

* MAC주소: 하드웨어의 정보
  IP주소: 하드웨어의 위치 정보

IP주소는 사람이 직접 할당하기도, 자동적으로 할당하기도 한다.

1. 프레임과 패킷
패킷: WAN 통신 시, MAC주소만으로는 통신이 불가능하기에, 프레임의 '데이터' 영역에 IP패킷을 넣는다.

간단한 IP패킷 형식: '  목적지 IP 주소 | 소스 IP 주소 | 데이터  '
라우팅에 대해 알아보자: LAN에서 나의 라우터에 IP패킷을 감싼 프레임 전송 -> 라우터간의 통신(라우팅) 시에는 MAC주소가 필요없기에 패킷만 전송 -> 목적지 컴퓨터의 라우터에 도착 시 다시 프레임으로 감쌈 -> 목적지 컴퓨터에 도착

2. 라우터
서로다른 라우터를 사용하는 컴퓨터간의 통신 시, 만약 내 LAN의 라우터가 방금 생성되었다면, 프레임에 감싸서 정보를 전송해야 하지만 정보를 전송하는 컴퓨터는 내 라우터의 MAC 주소를 모른다. 하지만 IP주소는 안다! - IP주소는 전략적으로 할당 가능하기 때문.)
내 라우터의 IP주소를 통해서 내 라우터의 MAC주소를 알 수 있다.

3. Address Resolution Protocol (ARP)
지금 단계에서는 내 라우터의 MAC주소를 알기위한 패킷이라 생각하자. (프레임에 감싸짐)

간단한 ARP패킷 형식: 
' Operation(1. 물어보는 패킷, 2. 답장 패킷) | 보내는 이의 MAC주소 | 보내는 이의 IP주소 | 목적지의 MAC주소(물어보는 패킷일 시 ff:ff:ff:ff) | 목적지의 IP주소 '

ARP 간단한 과정:
1) 컴퓨터 A가 프레임과 request ARP 패킷 생성 
	- [ ARP request 패킷. From: 192.168.10.4 To: 192.168.10.1 이 ip주소 갖는 디바이스(여기서는 라우터)의 MAC주소가 뭐야? ]

2) 프레임과 ARP 패킷을 LAN에 있는 모든 디바이스에 브로드캐스트

3) ARP 패킷에 담긴 목적지 IP주소와 자신의 IP주소가 맞는지 모든 디바이스가 확인. 이 단계에서 라우터가 매칭된 것을 확인한다)

4) 라우터가 프레임과 자신의 MAC주소를 담은 reply ARP 패킷 생성	
- [ ARP reply 패킷. From: 192.168.10.1 To: 192.168.10.4 내 MAC 주소는 이거야. 00:1a:74:33:44:e7 ]

5) 라우터가 컴퓨터 A에 프레임과 ARP 답장 패킷 전송

6) 라우터로부터 수신한 컴퓨터 A는 프레임에 제대로 된 라우터의 MAC주소와 "IP패킷" 담은 후 라우터에 전송! -> 라우터는 다음 라우터에 전송할 수 있다.(WAN)


4. 컴퓨터 A에서 컴퓨터 B로 정보 전송 과정 ( LAN -> WAN -> LAN )
   컴퓨터 A에서 보낸 정보를 LAN 라우터가 IP패킷의 목적지 IP 확인한다. 
-> 라우팅 테이블에서 패킷을 보낼 다음 라우터를 확인한다.
-> *라우터간 통신을 위한 PPP프레임(Point to Point)에 IP패킷을 감싼다.(이더넷 프레임과 다름!)
-> 다음 라우터로 전송한다.
-> 수신한 라우터는 라우팅 테이블 확인 후 같은 과정을 반복한다.
-> 컴퓨터 B의 LAN 라우터가 수신한다.
-> 해당 라우터는 PPP프레임의 IP패킷을 확인한다.
-> 목적지 IP주소를 확인 후, 라우팅 테이블을 확인하면 자기 자신이다.
-> 목적지 IP주소에 해당하는 MAC주소로 이더넷프레임으로 정보를 보낸다.
-> 만약 라우터가 목적지 IP주소에 해당하는 MAC주소를 모른다면, ARP request로 MAC주소를 알아낸다.
-> 컴퓨터 B가 정보를 받음!



° Internet Protocol 시작

1. IPv4
IPv4 주소 구조: 0~255.0~255.0~255.0~255
총 4바이트.
2^32 개(약 43억개)의 주소를 나타낼 수 있다. -> 부족하기 때문에 IPv6 등장

각 네트워크 클래스에 따른 IPv4 주소 구조(총 4바이트): 
Class A Network: 네트워크 | 호스트 | 호스트 | 호스트 (각 1바이트)
Class B Network: 네트워크 | 네트워크 | 호스트 | 호스트 (각 1바이트)
Class C Network: 네트워크 | 네트워크 | 네트워크 | 호스트 (각 1바이트)
- 네트워크 부분은 어떤 네트워크인지 식별한다.
  호스트 부분은 네트워크에 연결되어있는 각각의 디바이스를 식별한다.

클래스 A 네트워크:
네트워크 1바이트, 호스트 3바이트이다. -> 수많은 디바이스를 연결할 수 있다. -> 초거대 기업 또는 인터넷 제공 기업이 사용
클래스 A 네트워크의 범위: 1 ~ 126

클래스 B 네트워크:
네트워크 2바이트, 호스트 2바이트 -> 많은 인터넷 제공 기업들이 사용한다.
클래스 B 네트워크의 범위: 128 ~ 191 ( 127은 localhost이다.)

클래스 C 네트워크:
네트워크 3바이트, 호스트 1바이트 -> 네트워크 수가 가장 많기 때문에 작은 기업이나 개인용으로 쓰인다.
클래스 C 네트워크의 범위: 192 ~ 223 

2. Subnet Mask: 
Subnet Mask는 네트워크 부분을 나타낸다. ( IPv4의 네트워크 부분을 255로 나타냄)

Subnet Mask 예제: IPv4 주소, Subnet Mask
20.10.3.4 , 255.0.0.0 -> 클래스 A 네트워크
132.10.0.1 , 255.255.0.0 -> 클래스 B 네트워크
203.10.3.1 , 255.255.255.0  -> 클래스 C 네트워크 
-> Subnet Mask를 통해 어떤 클래스의 네트워크인지 추론이 가능하다!

Q. 	굳이 서브넷 마스크가 없더라도 네트워크 범위를 통해 무슨 클래스의 네트워크인지 알 수 있는데,
	(예를들면 20.10.3.4에서 20임을 확인 후 클래스 A 네트워크임을 추론 할 수 있음)
	굳이 서브넷 마스크가 필요한 이유는 뭘까?
A. 	1. 네트워크와 호스트 부분을 나눕니다: 서브넷 마스크는 IP 주소를 '네트워크 ID'와 '호스트 ID'로 나누는 역할을 합니다. 
	이를 통해, 특정 IP 주소가 어느 네트워크에 속하고, 그 네트워크 내에서 어떤 호스트를 지칭하는지를 알 수 있게 됩니다.
	2. 라우팅을 가능하게 합니다: 라우터는 패킷을 어디로 전달해야 할지 결정하는 데 서브넷 마스크를 사용합니다. 
	서브넷 마스크를 통해 대상 호스트가 속한 네트워크를 파악하고, 패킷을 해당 네트워크로 전달할 수 있습니다.
	3. 네트워크 설계 및 분할에 유용합니다: 서브넷 마스크를 통해 하나의 큰 네트워크를 여러 개의 작은 서브넷으로 나눌 수 있습니다. 
	이는 네트워크 관리를 용이하게 하며, 트래픽을 분산시키고 네트워크 성능을 향상시키는 데 도움이 됩니다.


3. Slash Notation(CIDR): IPv4가 어떤 클래스의 IP주소인지 알기위해 서브넷 마스크 에서 1의 개수를 알려줌.
ex) class A Network - IPv4: 20.10.3.4, Subnet Mask: 255.0.0.0, Slash Notation(CIDR): /8
    class B Network - IPv4: 132.10.0.1, Subnet Mask: 255.255.0.0, Slash Notation(CIDR): /16


4. 서브네팅
하나의 네트워크를 사용중이라면, 라우터 없이 스위치만으로도 통신이 가능하다!
하지만, 예를 들어 한 회사의 4개 부서에서 각각 다른 클래스 C 네트워크를 사용한다면, 4개의 네트워크와 4개의 라우터가 필요하다.
그러나, 클래스 C 네트워크는 254개의 호스트 주소가 사용 가능하지만, 각 부서에서 60개씩만 쓴다면 네트워크가 낭비된다.(== 돈낭비이다) 

* 그래서 나타난 개념이 서브네팅.
: 네트워크 하나를 여러의 네트워크로 쪼개는 것 !
ex) 클래스 C 네트워크 IPv4 200.100.100.0 을 사용중이고, 총 4개의 네트워크로 쪼개었다면
200.100.100.0/26 , 200.100.100.64/26 , 200.100.100.128/26 , 200.100.100.196/26 이다.
또한 Slash Notation 또한 24 -> 26으로 바뀐다. 그 이유 Subnet Mask가 255.255.255.192로 바뀌었기 때문이다.

*  Subnet Mask가 255.255.255.192로 바뀐 이유:
서브네팅은 호스트 주소의 일부분을 빌려서 네트워크 주소로 바꾸는 것이다.
-> 기존 클래스 C 네트워크 Subnet Mask: 11111111.11111111.11111111.00000000
   서브네팅한(기존 네트워크를 4개로 쪼갠) 클래스 C 네트워크: 11111111.11111111.11111111.11000000
-> 호스트 주소에서 2개의 비트를 빌려왔다. 11000000 == 십진수 192 
따라서 Subnet Mask가 255.255.255.192 이고, Slash Notation(CIDR)는 /26 인 것이다.

클래스 C 네트워크 서브네팅의 경우에는, 호스트에서 최대 6비트 까지 빌려올 수 있다.
따라서 CIDR은 /24 ~ /30의 범위를 가지며, 호스트 수는 0비트부터 차례로 254, 126, 62, 30, 14, 6, 2 이다.
사용 가능한 호스트의 수가 절반보다 2개씩 줄어드는 이유는 총 범위에서 네트워크 주소와 브로드캐스트 주소를 빼야하기 때문이다.



° Public IP vs Private IP

1. Public IP (공인 주소)
: 등록이 되어있다,
인터넷 서비스 공급자가 제공한다,
전세계에서 유일한 IP주소를 갖는다,
위치정보를 가지고 있다,
라우팅이 가능하다.

2. Private IP (사설 주소)
: 등록이 되어있지 않다,
누구나 사용 가능하다,
쓰고 또 쓸 수 있다,
위치정보를 가지지 않는다,
라우팅이 불가능하다.

3. Private IP 주소
1) 클래스 A 네트워크의 IP주소 범위: 10.0.0.0 ~ 10.255.255.255
2) 클래스 B 네트워크의 IP주소 범위: 172.16.0.0 ~ 172.31.255.255
3) 클래스 C 네트워크의 IP주소 범위: 192.168.0.0 ~ 192.168.255.255
	-> IP주소를 확인하면 Public IP인지, Private IP인지 구별이 가능하다.

주로 LAN은 Private IP로, WAN에 진입하기 위해서는 Public IP를 이용하도록 설계되어있다.


° IP 할당 - DHCP 프로토콜

1. DHCP / Static
 DHCP(Dynamic Host Configuration Protocol) : IP를 자동적으로 할당하는 프로토콜. - 인터넷에 연결이 되면 IP가 자동적으로 설정된다.(가변적이다)
 Static : IP를 직접 할당하는 프로토콜.

컴퓨터, 핸드폰, TV 등의 디바이스는 DHCP를 이용한 IP 자동할당을, 
인터넷 이용을 위한 고정 IP주소가 필요한 라우터는 IP를 직접 할당한다.

* 규모가 큰 네트워크에서는 DHCP를 주로 이용한다. ( IP주소가 고정되어야 하는 라우터, 프린터 등은 제외!)

2. DHCP 프로토콜 자세히 알아보기
- LAN에 연결된 컴퓨터의 IP주소 할당하기
: DHCP 서버를 가지는 디바이스를 LAN에 연결한다. -> DHCP 서버가 IP를 자동적으로 할당한다.
Q) DHCP 서버를 갖는 디바이스는 어디에 있을까? A) 공유기(스위치)에 탑재되어있다.

Step 1) DHCP Discover : 
LAN에 연결된 컴퓨터 A에서 IP를 할당받기 위한 DHCP 서버 디바이스를 찾기 위해 
이더넷프레임 메세지를 이용하여 모든 디바이스에 브로드캐스팅한다.
(이 때, MAC주소와 IP주소는 모두 브로드캐스팅 주소로 사용한다.)

Step 2) DHCP Offer :
메세지를 수신한 DHCP 서버가 사용 가능한 IP주소를 브로드캐스팅한다.

Step 3) DHCP Request :
컴퓨터 A는 Request 해당 IP주소를 사용하겠다는 메세지를 전송한다.

Step 4) DHCP Acknowledgement :
DHCP 서버는 메세지를 확인하고, IP주소를 사용하기 위한 부가적인 정보를 브로드캐스팅한다.
(IP주소, 서브넷 마스크, Default Gateway, Lease Time ... )

* DHCP 메세지 구조: 이더넷 프레임 내부에 IP 패킷 내부에 UDP Segment 내부에 DBCP 메세지 가 있다.


° Transport Layer Protocols (전송 계층 프로토콜)
1. 포트의 개념: 논리적 접속 위치 
하나의 IP주소(컴퓨터)에 여러가지의 네트워크 프로세스가 일어날 수 있다.(ex: HTTP, SSH, SFTP가 동시에 일어날 수 있음)
그렇게 되면, 프로토콜들을 구별해야 한다. -> 각각의 프로토콜에 따른 포트로 구별한다.
ex) HTTP 프로토콜의 포트: 192.168.10.1:80 , SSH 프로토콜의 포트: 192.168.10.1:22 , etc... 
->  192.168.10.1:80과 같이 IP주소와 포트로 만든 가상의 통로를 "소켓" 이라 한다.

2. 자주 쓰이는 프로토콜과 포트

포트	|	프로토콜		|	용도
20	|	FTP		|	데이터 전송
22	|	SSH		|	Secure Shell	
22	|	SFTP		|	데이터 전송
25	|	SMTP		|	이메일 전송
53	|	DNS		|	Domain Name Service
80	|	HTTP		|	웹 페이지 전송
443	|	HTTPS		|	웹 페이지 전송

Port Numbers	|	설명
0 - 1023	|	잘 알려진 프로토콜
1024 - 49151	|	잘 알려지진 않았지만 등록된 프로토콜
49152 - 65535	|	누구나 사용 가능한 포트


° TCP(Transmission Control Protocol)
지금까지 배운 네트워크 소통은 이더넷 프레임 내부의 IP패킷을 통해 통신했다.
하지만 Internet Protocol에는 단점이 있다 : 
1) 데이터 전달이 이루어지지 않을 수 있다.(데이터를 보내기만 하고, 잘 전달되었는지 확인하지 않기 때문)
2) 라우팅 과정에 패킷이 버려질 수 있다.
3) framing이 제대로 이루어지지않아 데이터가 손상될 수 있다.

1. TCP: Internet Protocol 의 단점을 보완하기 위해 만들어진 프로토콜.
TCP는 어플리케이션 소통이 끝날 때 까지 커넥션(소켓)이 종료되지 않는다.
또한, 데이터가 잘 전달되었는지 확인하고, 전달되지 않았다면 다시 전송한다.
-> 안전한 데이터 전송 방식이다.

2. TCP 구조
이더넷 프레임 내부의 IP패킷 내부의 '데이터' 영엑이 TCP 세그먼트를 넣는다.
TCP 세그먼트의 간단한 형식: 소스 포트 | 목적지 포트 | 시퀀스 넘버 | Acknowledgement 넘버 | Checksum | 데이터

3. TCP 자세히 알아보기

1. 서로다른 네트워크를 이용하는 클라이언트 컴퓨터 A에서 서버 컴퓨터 B로 TCP 프로토콜로 통신을 하려 한다.
2. IP 패킷의 Protocol 섹션이 '6' 이면 TCP이다. -> Protocol 섹션이 어떤 넘버냐에 따라 '데이터' 영역의 형식이 바뀐다.
3. IP 패킷의 Source Address와 Destination Address는 컴퓨터 A, B의 각각의 IP 주소이다.
4. IP 패킷의 '데이터' 영역의 TCP 세그먼트에는 소스 포트, 목적지 포트가 있다.
5. 컴퓨터 A는 Sequence Number:0 형식으로(시퀀스 넘버 뒤의 숫자는 랜덤) TCP 메세지(Synchronize flag)를 보낸다.
6. 컴퓨터 B는 Acknowledge Number:1 , Sequence Number:0 등의 형식으로 확인 메세지(Synchronize flag)를 보낸다.
7. 컴퓨터 A는 다시  Acknowledge Number:1 , Sequence Number:1 의 형식으로 컴퓨터 B에 전송하고, 
이 과정을 Three way Handshake 라 한다.
8. TCP 연결 성공이 되었고, 현재까지는 아무 데이터도 존재하지 않는다.
9. 컴퓨터 B는 TCP 세그먼트의 포트 번호에 담긴 데이터를 데이터 크기,  Sequence Number:1 형식으로 전송한다. 
(ex: 목적지 포트: 13 이고, 해당 포트의 용도는 날짜, 시간 전송이라면, 컴퓨터 A에 날짜, 시간을 전송한다.)
10. 컴퓨터 A는 Acknowledge Number:23 의 형식으로 컴퓨터 B에 다시 전송한다.(23인 이유는 Sequence Number + 데이터 크기)
11. 통신의 목적이 달성했으므로 TCP 연결을 종료하기 위해 컴퓨터 B는 FIN(Final) flag를 Sequence Number:23 의 형식으로 전송한다.
12. 컴퓨터 A는 Acknowledge Number:24 의 형식으로 다시 전송하지만, 컴퓨터 B는 종료 플래그를 전송했기 때문에 응답이 없다.
13. 컴퓨터 A는 다시 FIN(Final) flag를 Sequence Number:1 의 형식으로 전송한다.
14. 컴퓨터 B는 마지막으로  Acknowledge Number:2 의 형식으로 응답을 보내고, 컴퓨터 A와 B 모두 Finalize 했으므로 TCP 연결이 종료된다.


° UDP (User Datagram Protocol)

1. UDP : 동영상이나 웹 스트리밍을 할 때 주로 사용되는 프로토콜.
UDP는 Connectionless로 어플리케이션 소통이 안전하지 않다.
UDP는 데이터가 잘 전송되었는지 확인하지 않는다. 따라서, 제대로 전달이 되지 않았을 시에도 재전송하지않는다.

2. UDP의 장점 :
TCP보다 빠르고 가볍다.
TCP 헤더는 20바이트이지만, UDP 헤더는 8바이트이다. 또한, UDP는 데이터의 전송 여부를 확인하지 않기 때문에 빠르다.

3. UDP 구조:
TCP와 마찬가지로 이더넷 프레임 내부에 IP 패킷 내부의 '데이터' 영역에 UDP 세그먼트가 담긴다.
하지만 UDP 세그먼트의 형식은 TCP 세그먼트보다 훨씬 간단하다.



** ° Application Layer Protocols
- 개발자가 가장 많이 이용하는 Internet Protocol 계층으로,
이 계층의 많은 프로토콜이 TCP 또는 UDP를 기반으로한다.

TCP 세그먼트 또는 UDP 세그먼트의 '데이터' 영역에  Application 계층의 프로토콜(DHCP, SSH, SMTP, HTTP 등)을 담는다!

1. UDP / TCP 기반 프로토콜들

- DHCP: 네트워크에 연결된 디바이스들의 IP 주소를 자동적으로 할당해주는 프로토콜. : UDP 
Ports: 67, 68

- DNS: 도메인 주소를 IP 주소로 변경해주는 프로토콜.(ex: naver.com -> 223.130.195.200) : UDP
Ports: 53

- DayTime : 현재 날짜와 시간을 알려주는 프로토콜 : TCP / UDP
Ports: 13

- SSH : 멀리 떨어져있는 호스트를 원격으로 연결시켜주는 프로토콜 : TCP
Ports: 22
암호화를 사용해서 정보 교환을 보호할 수 있다.

- SFTP : SSH를 활용하여 시스템간 파일 전송을 하는 프로토콜 : TCP
Ports: 22 
데이터가 암호화되어 전송되기 때문에 보안이 철저하다.

- SMTP : 클라이언트에서 이메일 서버에 이메일 전송하는 프로토콜. : TCP
Ports: 25
암호화를 사용하여 이메일 전송이 가능하다.

- IMAP : 서버에서 이메일을 가져오는 프로토콜. : TCP
Ports: 143
유저가 이메일 서버에 접속해서 메일을 보고 다운받을 수 있게 해주는 프로토콜이다.
여러 디바이스에서 이메일 서버에 접속이 가능하다.(Gmail)

- HTTP : 웹사이트 브라우징 프로토콜. : TCP
Port: 80
웹서버에 정보를 요청(request) 하고 웹서버는 응답(reply) 한다.
HTML을 사용하여 정보를 전달한다.
데이터가 텍스트로 전달되기 때문에 보안이 취약하다.

- HTTPS : 암호화를 사용한 HTTPS 프로토콜 : TCP 
Port: 443 
데이터가 암호화되어 전달되기 때문에 보안이 철저하다.



° TCP/IP Model

Application Layer	- Data
-----------------
Transport Layer		- Segment
-----------------
Internet Layer		- Packet
-----------------
Network Access Layer	- Frame
-----------------

-> Internet 안에서 컴퓨터는 Frame 안에 Packet 안에 Segment 안에 Data 를 감싼 형식으로 데이터를 주고받는다.











